export const QuizQuestions=
[
  {
    "question": "What is the primary benefit of using React Native's Fast Refresh feature during development?",
    "options": [
      "It automatically refactors your code to improve performance.",
      "It provides real-time updates to your code without losing component state.",
      "It allows you to debug your code directly on the device.",
      "It generates optimized production builds faster."
    ],
    "answer": "It provides real-time updates to your code without losing component state."
  },
  {
    "question": "How does React Native bridge the gap between JavaScript code and native platform components?",
    "options": [
      "It uses a JavaScript engine to interpret JavaScript code directly on the native platform.",
      "It translates JavaScript code into native code at compile time.",
      "It uses a message queue to asynchronously communicate between JavaScript and native threads.",
      "It replaces native components with JavaScript-based alternatives."
    ],
    "answer": "It uses a message queue to asynchronously communicate between JavaScript and native threads."
  },
  {
    "question": "What is the purpose of the `useCallback` hook in React Native functional components?",
    "options": [
      "To memoize the result of a function call and prevent unnecessary re-renders.",
      "To manage the lifecycle of a functional component.",
      "To define a function that is called when a component is unmounted.",
      "To prevent the creation of a new function instance on every render."
    ],
    "answer": "To prevent the creation of a new function instance on every render."
  },
  {
    "question": "Which React Native API is used to manage asynchronous operations and background tasks?",
    "options": [
      "AsyncStorage",
      "Fetch",
      "BackgroundFetch",
      "Promise"
    ],
    "answer": "Fetch"
  },
  {
    "question": "What is the significance of using the `Platform` API in React Native?",
    "options": [
      "To access platform-specific information and adapt code based on the operating system.",
      "To directly modify the native UI components of the platform.",
      "To optimize the performance of React Native applications for different screen sizes.",
      "To enable cross-platform code sharing with web applications."
    ],
    "answer": "To access platform-specific information and adapt code based on the operating system."
  },
  {
    "question": "When would you choose to use a `FlatList` component over a `ScrollView` in React Native?",
    "options": [
      "When you need to render a small, static list of items.",
      "When you want to render a dynamic list of items with potentially large dataset that benefits from virtualization.",
      "When you need to implement custom animations for scrolling.",
      "When you want to create a fixed layout with no scrolling."
    ],
    "answer": "When you want to render a dynamic list of items with potentially large dataset that benefits from virtualization."
  },
  {
    "question": "What is the purpose of using Redux or similar state management libraries in a React Native application?",
    "options": [
      "To simplify UI rendering and improve performance.",
      "To manage global application state and facilitate data sharing between components.",
      "To handle navigation and routing between different screens.",
      "To implement persistent storage for user data."
    ],
    "answer": "To manage global application state and facilitate data sharing between components."
  },
  {
    "question": "How can you improve the performance of a React Native application when dealing with complex animations?",
    "options": [
      "By using JavaScript-based animations exclusively.",
      "By offloading animations to the native driver using `useNativeDriver: true`.",
      "By reducing the number of animations used in the application.",
      "By increasing the frame rate of animations."
    ],
    "answer": "By offloading animations to the native driver using `useNativeDriver: true`."
  },
  {
    "question": "What is the recommended way to handle navigation between screens in a React Native application with a complex navigation structure?",
    "options": [
      "Using the built-in `Navigator` component.",
      "Using a third-party navigation library like React Navigation or react-native-navigation.",
      "Implementing custom navigation logic using state management.",
      "Using deep linking to navigate between screens."
    ],
    "answer": "Using a third-party navigation library like React Navigation or react-native-navigation."
  },
  {
    "question": "What are the advantages of using TypeScript with React Native projects?",
    "options": [
      "It automatically optimizes your code for performance.",
      "It provides static typing, improved code maintainability, and early error detection.",
      "It simplifies the process of building native modules.",
      "It eliminates the need for testing."
    ],
    "answer": "It provides static typing, improved code maintainability, and early error detection."
  }
]